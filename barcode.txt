#pragma config(Sensor, S1,     Color,          sensorEV3_Color)
#pragma config(Motor,  motorA,          motor1,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          motor2,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//motor 1 (1:5) gear ratio; motor2 (1:40) gear ratio

int encodeValueMotor1 = 90;	//not sure b/w 90 & 0
int encodeValueMotor2 = 0;
//int degreeMotor1 = 0;
//int degreeMotor2 = 0;
float L1 = 19.7;
int L2 = 10;
float x = 0;
float y = 0;
float theta2_x = 0;
float theta2_y = 0;
float theta2 = 0;
float theta1 = 0;
int ccw_motor_speedA = 5;
int cw_motor_speedA = -5;
int ccw_motor_speedD = -40;
int cw_motor_speedD = 40;
float k1 = 0;
float k2 = 0;

task main()
{
	//moving to starting position
	y = L1+L2;

	while(x >= -14 && y >= 10.8 + 12){
		theta2_y = sqrt(1-((x^2+y^2-L1^2-L2^2)/(2*L1*L2))^2);
		theta2_x = (x^2+y^2-L1^2-L2^2)/(2*L1*L2);
		theta2 = atan2(-theta2_y,theta2_x);

		k1 = L1+L2*cos(theta2);
		k2 = L2*sin(theta2);
		theta1 = atan2(y,x)-atan2(k2,k1);
		
		//cover rad to deg
		theta1 = theta1*180/PI;
		theta2 = theta2*180/PI;
		
		while( abs(encodeValueMotor1/5 < abs(theta1)) || encodeValueMotor2/40) < abs(theta2)){
			encodeValueMotor1 = getMotorEncoder(motorA);
			encodeValueMotor2 = getMotorEncoder(motorD);

			if(theta1>0 && abs(encodeValueMotor1/5)<abs(theta1)){
				motor[motorA] = ccw_motor_speedA;
			}
			else if(theta1<0 && abs(encodeValueMotor1/5)<abs(theta1)){
				motor[motorA] = cw_motor_speedA;
			}
			else{
				motor[motorA] = 0;
			}

			if(theta2>0 && abs(encodeValueMotor2/40)<abs(theta2)){
				motor[motorD] = ccw_motor_speedD;
			}
			else if(theta2<0 && abs(encodeValueMotor2/40)<abs(theta2)){
				motor[motorD] = cw_motor_speedD;
			}
			else{
				motor[motorD] = 0;
			}

			x -= 1;
			y -= 0.49;
		}
	}


	//Scanning	
	x = -14;
	y = 10.8 + 12;

	while(x <= 14){
		theta2_y = sqrt(1-((x^2+y^2-L1^2-L2^2)/(2*L1*L2))^2);
		theta2_x = (x^2+y^2-L1^2-L2^2)/(2*L1*L2);
		theta2 = atan2(-theta2_y,theta2_x);

		k1 = L1+L2*cos(theta2);
		k2 = L2*sin(theta2);
		theta1 = atan2(y,x)-atan2(k2,k1);
		
		//cover rad to deg
		theta1 = theta1*180/PI;
		theta2 = theta2*180/PI;
		
		while((abs(encodeValueMotor2/40) - abs(theta2)) != 0 || (abs(encodeValueMotor2/40) - abs(theta2)) != 0){
			encodeValueMotor1 = getMotorEncoder(motorA);
			encodeValueMotor2 = getMotorEncoder(motorD);

			if((abs(encodeValueMotor1/5) - abs(theta1)) > 0 && abs(encodeValueMotor1/5) > abs(theta1)){
				motor[motorA] = ccw_motor_speedA;
			}
			else if((abs(encodeValueMotor1/5) - abs(theta1)) < 0 && abs(encodeValueMotor1/5) < abs(theta1)){
				motor[motorA] = cw_motor_speedA;
			}
			else{
				motor[motorA] = 0;
			}

			if((abs(encodeValueMotor2/40) - abs(theta2)) > 0 && abs(encodeValueMotor2/40) > abs(theta2)){
				motor[motorD] = ccw_motor_speedD;
			}
			else if((abs(encodeValueMotor2/40) - abs(theta2)) < 0 && abs(encodeValueMotor2/40) < abs(theta2)){
				motor[motorD] = cw_motor_speedD;
			}
			else{
				motor[motorD] = 0;
			}
			x += 0.1;
		}	

	}

}


/* Other option
			if((abs(encodeValueMotor1/5) - abs(theta1)) > 0){
				while(abs(encodeValueMotor1/5) > abs(theta1)){
					motor[motorA] = ccw_motor_speedA;
				}
			}
			else if((abs(encodeValueMotor1/5) - abs(theta1)) < 0){
				while(abs(encodeValueMotor1/5) < abs(theta1)){
					motor[motorA] = cw_motor_speedA;
				}
			}
			else{
				motor[motorA] = 0;
			}

//test for motor1 first, if its work change motor 2 to be like motor 1
			if((abs(encodeValueMotor2/40) - abs(theta2)) > 0 && abs(encodeValueMotor2/40) > abs(theta2)){
				motor[motorD] = ccw_motor_speedD;
			}
			else if((abs(encodeValueMotor2/40) - abs(theta2)) < 0 && abs(encodeValueMotor2/40) < abs(theta2)){
				motor[motorD] = cw_motor_speedD;
			}
			else{
				motor[motorD] = 0;
			}
*/







